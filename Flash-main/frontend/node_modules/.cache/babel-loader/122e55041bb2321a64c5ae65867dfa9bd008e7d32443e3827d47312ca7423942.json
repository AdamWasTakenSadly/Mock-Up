{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport merge from 'lodash/merge';\nimport { useResourceContext } from '../core';\nimport { useDataProvider } from '../dataProvider';\nimport { useTranslate, useTranslateLabel } from '../i18n';\nimport { useCallback, useRef } from 'react';\nimport set from 'lodash/set';\nimport { asyncDebounce } from '../util';\nimport { useRecordContext } from '../controller';\n/**\n * A hook that returns a validation function checking for a record field uniqueness\n * by calling the dataProvider getList function with a filter.\n *\n * @example // Passing options at declaration time\n * const UserCreateForm = () => {\n *     const unique = useUnique({ message: 'Username is already used'});\n *     return (\n *         <SimpleForm>\n *             <TextInput source=\"username\" validate={unique()} />\n *         </SimpleForm>\n *     );\n * }\n *\n * @example // Passing options at call time\n * const UserCreateForm = () => {\n *     const unique = useUnique();\n *     return (\n *         <SimpleForm>\n *             <TextInput source=\"username\" validate={unique({ message: 'Username is already used'})} />\n *         </SimpleForm>\n *     );\n * }\n *\n * @example // With additional filters\n * const UserCreateForm = () => {\n *     const unique = useUnique();\n *     return (\n *         <SimpleForm>\n *             <ReferenceInput source=\"organization_id\" reference=\"organizations\" />\n *             <FormDataConsumer>\n *                 {({ formData }) => (\n *                     <TextInput\n *                         source=\"username\"\n *                         validate={unique({ filter: { organization_id: formData.organization_id })}\n *                     />\n *                 )}\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     );\n * }\n */\nexport var useUnique = function (options) {\n  var _a;\n  var dataProvider = useDataProvider();\n  var translateLabel = useTranslateLabel();\n  var resource = useResourceContext(options);\n  var translate = useTranslate();\n  var record = useRecordContext();\n  var debouncedGetList = useRef(\n  // The initial value is here to set the correct type on useRef\n  asyncDebounce(dataProvider.getList, (_a = options === null || options === void 0 ? void 0 : options.debounce) !== null && _a !== void 0 ? _a : DEFAULT_DEBOUNCE));\n  var validateUnique = useCallback(function (callTimeOptions) {\n    var _a = merge({\n        debounce: DEFAULT_DEBOUNCE,\n        filter: {},\n        message: 'ra.validation.unique'\n      }, options, callTimeOptions),\n      message = _a.message,\n      filter = _a.filter,\n      interval = _a.debounce;\n    debouncedGetList.current = asyncDebounce(dataProvider.getList, interval);\n    return function (value, allValues, props) {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var finalFilter, _a, data, total, error_1;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 2,, 3]);\n              finalFilter = set(merge({}, filter), props.source, value);\n              return [4 /*yield*/, debouncedGetList.current(resource, {\n                filter: finalFilter,\n                pagination: {\n                  page: 1,\n                  perPage: 1\n                },\n                sort: {\n                  field: 'id',\n                  order: 'ASC'\n                }\n              })];\n            case 1:\n              _a = _b.sent(), data = _a.data, total = _a.total;\n              if (total > 0 && !data.some(function (r) {\n                return r.id === (record === null || record === void 0 ? void 0 : record.id);\n              })) {\n                return [2 /*return*/, translate(message, {\n                  _: message,\n                  source: props.source,\n                  value: value,\n                  field: translateLabel({\n                    label: props.label,\n                    source: props.source,\n                    resource: resource\n                  })\n                })];\n              }\n              return [3 /*break*/, 3];\n            case 2:\n              error_1 = _b.sent();\n              return [2 /*return*/, translate('ra.notification.http_error')];\n            case 3:\n              return [2 /*return*/, undefined];\n          }\n        });\n      });\n    };\n  }, [dataProvider, options, record, resource, translate, translateLabel]);\n  return validateUnique;\n};\nvar DEFAULT_DEBOUNCE = 1000;","map":{"version":3,"mappings":"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","names":["merge","useResourceContext","useDataProvider","useTranslate","useTranslateLabel","useCallback","useRef","set","asyncDebounce","useRecordContext","useUnique","options","dataProvider","translateLabel","resource","translate","record","debouncedGetList","getList","debounce","DEFAULT_DEBOUNCE","validateUnique","callTimeOptions","filter","message","interval","current","value","allValues","props","finalFilter","source","pagination","page","perPage","sort","field","order","_a","_b","data","total","some","id","_","label","undefined"],"sources":["D:\\Work\\Mock-Up\\Flash-main\\frontend\\node_modules\\react-admin\\node_modules\\ra-core\\src\\form\\useUnique.ts"],"sourcesContent":["import merge from 'lodash/merge';\nimport { useResourceContext } from '../core';\nimport { useDataProvider } from '../dataProvider';\nimport { useTranslate, useTranslateLabel } from '../i18n';\nimport { InputProps } from './useInput';\nimport { useCallback, useRef } from 'react';\nimport set from 'lodash/set';\nimport { asyncDebounce } from '../util';\nimport { useRecordContext } from '../controller';\n\n/**\n * A hook that returns a validation function checking for a record field uniqueness\n * by calling the dataProvider getList function with a filter.\n *\n * @example // Passing options at declaration time\n * const UserCreateForm = () => {\n *     const unique = useUnique({ message: 'Username is already used'});\n *     return (\n *         <SimpleForm>\n *             <TextInput source=\"username\" validate={unique()} />\n *         </SimpleForm>\n *     );\n * }\n *\n * @example // Passing options at call time\n * const UserCreateForm = () => {\n *     const unique = useUnique();\n *     return (\n *         <SimpleForm>\n *             <TextInput source=\"username\" validate={unique({ message: 'Username is already used'})} />\n *         </SimpleForm>\n *     );\n * }\n *\n * @example // With additional filters\n * const UserCreateForm = () => {\n *     const unique = useUnique();\n *     return (\n *         <SimpleForm>\n *             <ReferenceInput source=\"organization_id\" reference=\"organizations\" />\n *             <FormDataConsumer>\n *                 {({ formData }) => (\n *                     <TextInput\n *                         source=\"username\"\n *                         validate={unique({ filter: { organization_id: formData.organization_id })}\n *                     />\n *                 )}\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     );\n * }\n */\nexport const useUnique = (options?: UseUniqueOptions) => {\n    const dataProvider = useDataProvider();\n    const translateLabel = useTranslateLabel();\n    const resource = useResourceContext(options);\n    const translate = useTranslate();\n    const record = useRecordContext();\n\n    const debouncedGetList = useRef(\n        // The initial value is here to set the correct type on useRef\n        asyncDebounce(\n            dataProvider.getList,\n            options?.debounce ?? DEFAULT_DEBOUNCE\n        )\n    );\n\n    const validateUnique = useCallback(\n        (callTimeOptions?: UseUniqueOptions) => {\n            const { message, filter, debounce: interval } = merge<\n                UseUniqueOptions,\n                any,\n                any\n            >(\n                {\n                    debounce: DEFAULT_DEBOUNCE,\n                    filter: {},\n                    message: 'ra.validation.unique',\n                },\n                options,\n                callTimeOptions\n            );\n\n            debouncedGetList.current = asyncDebounce(\n                dataProvider.getList,\n                interval\n            );\n\n            return async (value: any, allValues: any, props: InputProps) => {\n                try {\n                    const finalFilter = set(\n                        merge({}, filter),\n                        props.source,\n                        value\n                    );\n                    const { data, total } = await debouncedGetList.current(\n                        resource,\n                        {\n                            filter: finalFilter,\n                            pagination: { page: 1, perPage: 1 },\n                            sort: { field: 'id', order: 'ASC' },\n                        }\n                    );\n\n                    if (total > 0 && !data.some(r => r.id === record?.id)) {\n                        return translate(message, {\n                            _: message,\n                            source: props.source,\n                            value,\n                            field: translateLabel({\n                                label: props.label,\n                                source: props.source,\n                                resource,\n                            }),\n                        });\n                    }\n                } catch (error) {\n                    return translate('ra.notification.http_error');\n                }\n\n                return undefined;\n            };\n        },\n        [dataProvider, options, record, resource, translate, translateLabel]\n    );\n\n    return validateUnique;\n};\n\nconst DEFAULT_DEBOUNCE = 1000;\n\nexport type UseUniqueOptions = {\n    debounce?: number;\n    resource?: string;\n    message?: string;\n    filter?: Record<string, any>;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}