{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as React from 'react';\nimport { useResourceContext, usePreference, useStore, useTranslate } from 'ra-core';\nimport { Configurable } from '../../preferences';\nimport { Datagrid } from './Datagrid';\nimport { DatagridEditor } from './DatagridEditor';\n/**\n * A Datagrid that users can customize in configuration mode\n *\n * @example\n * import {\n *     List,\n *     DatagridConfigurable,\n *     TextField,\n * } from 'react-admin';\n *\n * export const PostList = () => (\n *     <List>\n *         <DatagridConfigurable>\n *             <TextField source=\"id\" />\n *             <TextField source=\"title\" />\n *             <TextField source=\"author\" />\n *             <TextField source=\"year\" />\n *         </DatagridConfigurable>\n *     </List>\n * );\n */\nexport var DatagridConfigurable = function (_a) {\n  var preferenceKey = _a.preferenceKey,\n    omit = _a.omit,\n    props = __rest(_a, [\"preferenceKey\", \"omit\"]);\n  if (props.optimized) {\n    throw new Error('DatagridConfigurable does not support the optimized prop');\n  }\n  var translate = useTranslate();\n  var resource = useResourceContext(props);\n  var finalPreferenceKey = preferenceKey || \"\".concat(resource, \".datagrid\");\n  var _b = useStore(\"preferences.\".concat(finalPreferenceKey, \".availableColumns\"), []),\n    availableColumns = _b[0],\n    setAvailableColumns = _b[1];\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var _c = useStore(\"preferences.\".concat(finalPreferenceKey, \".omit\"), omit),\n    _ = _c[0],\n    setOmit = _c[1];\n  React.useEffect(function () {\n    // first render, or the preference have been cleared\n    var columns = React.Children.toArray(props.children).filter(function (child) {\n      return React.isValidElement(child);\n    }).map(function (child, index) {\n      return {\n        index: String(index),\n        source: child.props.source,\n        label: child.props.label && typeof child.props.label === 'string' // this list is serializable, so we can't store ReactElement in it\n        ? child.props.label : child.props.source ?\n        //  force the label to be the source\n        undefined :\n        // no source or label, generate a label\n        translate('ra.configurable.Datagrid.unlabeled', {\n          column: index,\n          _: \"Unlabeled column #%{column}\"\n        })\n      };\n    });\n    if (columns.length !== availableColumns.length) {\n      setAvailableColumns(columns);\n      setOmit(omit);\n    }\n  }, [availableColumns]); // eslint-disable-line react-hooks/exhaustive-deps\n  return React.createElement(Configurable, {\n    editor: React.createElement(DatagridEditor, null),\n    preferenceKey: finalPreferenceKey,\n    sx: {\n      display: 'block',\n      minHeight: 2\n    }\n  }, React.createElement(DatagridWithPreferences, __assign({}, props)));\n};\nDatagridConfigurable.propTypes = Datagrid.propTypes;\n/**\n * This Datagrid filters its children depending on preferences\n */\nvar DatagridWithPreferences = function (_a) {\n  var children = _a.children,\n    props = __rest(_a, [\"children\"]);\n  var availableColumns = usePreference('availableColumns', [])[0];\n  var omit = usePreference('omit', [])[0];\n  var columns = usePreference('columns', availableColumns.filter(function (column) {\n    return !(omit === null || omit === void 0 ? void 0 : omit.includes(column.source));\n  }).map(function (column) {\n    return column.index;\n  }))[0];\n  var childrenArray = React.Children.toArray(children);\n  return React.createElement(Datagrid, __assign({}, props), columns === undefined ? children : columns.map(function (index) {\n    return childrenArray[index];\n  }));\n};","map":{"version":3,"mappings":"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","names":["React","useResourceContext","usePreference","useStore","useTranslate","Configurable","Datagrid","DatagridEditor","DatagridConfigurable","_a","omit","props","optimized","Error","translate","resource","finalPreferenceKey","preferenceKey","availableColumns","setAvailableColumns","_","setOmit","useEffect","columns","Children","toArray","children","filter","isValidElement","child","map","index","String","source","label","undefined","column","length","editor","sx","display","minHeight","DatagridWithPreferences","propTypes","includes","childrenArray"],"sources":["D:\\Work\\Mock-Up\\Flash-main\\frontend\\node_modules\\react-admin\\node_modules\\ra-ui-materialui\\src\\list\\datagrid\\DatagridConfigurable.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n    useResourceContext,\n    usePreference,\n    useStore,\n    useTranslate,\n} from 'ra-core';\n\nimport { Configurable } from '../../preferences';\nimport { Datagrid, DatagridProps } from './Datagrid';\nimport { DatagridEditor } from './DatagridEditor';\n\n/**\n * A Datagrid that users can customize in configuration mode\n *\n * @example\n * import {\n *     List,\n *     DatagridConfigurable,\n *     TextField,\n * } from 'react-admin';\n *\n * export const PostList = () => (\n *     <List>\n *         <DatagridConfigurable>\n *             <TextField source=\"id\" />\n *             <TextField source=\"title\" />\n *             <TextField source=\"author\" />\n *             <TextField source=\"year\" />\n *         </DatagridConfigurable>\n *     </List>\n * );\n */\nexport const DatagridConfigurable = ({\n    preferenceKey,\n    omit,\n    ...props\n}: DatagridConfigurableProps) => {\n    if (props.optimized) {\n        throw new Error(\n            'DatagridConfigurable does not support the optimized prop'\n        );\n    }\n\n    const translate = useTranslate();\n    const resource = useResourceContext(props);\n    const finalPreferenceKey = preferenceKey || `${resource}.datagrid`;\n\n    const [availableColumns, setAvailableColumns] = useStore<\n        ConfigurableDatagridColumn[]\n    >(`preferences.${finalPreferenceKey}.availableColumns`, []);\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_, setOmit] = useStore<string[]>(\n        `preferences.${finalPreferenceKey}.omit`,\n        omit\n    );\n\n    React.useEffect(() => {\n        // first render, or the preference have been cleared\n        const columns = React.Children.toArray(props.children)\n            .filter(child => React.isValidElement(child))\n            .map((child: React.ReactElement, index) => ({\n                index: String(index),\n                source: child.props.source,\n                label:\n                    child.props.label && typeof child.props.label === 'string' // this list is serializable, so we can't store ReactElement in it\n                        ? child.props.label\n                        : child.props.source\n                        ? //  force the label to be the source\n                          undefined\n                        : // no source or label, generate a label\n                          translate('ra.configurable.Datagrid.unlabeled', {\n                              column: index,\n                              _: `Unlabeled column #%{column}`,\n                          }),\n            }));\n        if (columns.length !== availableColumns.length) {\n            setAvailableColumns(columns);\n            setOmit(omit);\n        }\n    }, [availableColumns]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return (\n        <Configurable\n            editor={<DatagridEditor />}\n            preferenceKey={finalPreferenceKey}\n            sx={{ display: 'block', minHeight: 2 }}\n        >\n            <DatagridWithPreferences {...props} />\n        </Configurable>\n    );\n};\n\nexport interface DatagridConfigurableProps extends DatagridProps {\n    /**\n     * Key to use to store the user's preferences for this datagrid.\n     *\n     * Set to '[resource].datagrid' by default. Pass a custom key if you need\n     * to display more than one ConfigurableDatagrid per resource.\n     */\n    preferenceKey?: string;\n    /**\n     * columns to hide by default\n     *\n     * @example\n     * // by default, hide the id and author columns\n     * // users can choose to show show them in configuration mode\n     * const PostList = () => (\n     *     <List>\n     *         <DatagridConfigurable omit={['id', 'author']}>\n     *             <TextField source=\"id\" />\n     *             <TextField source=\"title\" />\n     *             <TextField source=\"author\" />\n     *             <TextField source=\"year\" />\n     *         </DatagridConfigurable>\n     *     </List>\n     * );\n     */\n    omit?: string[];\n}\n\nexport interface ConfigurableDatagridColumn {\n    index: string;\n    source?: string;\n    label?: string;\n}\n\nDatagridConfigurable.propTypes = Datagrid.propTypes;\n\n/**\n * This Datagrid filters its children depending on preferences\n */\nconst DatagridWithPreferences = ({ children, ...props }: DatagridProps) => {\n    const [availableColumns] = usePreference('availableColumns', []);\n    const [omit] = usePreference('omit', []);\n    const [columns] = usePreference(\n        'columns',\n        availableColumns\n            .filter(column => !omit?.includes(column.source))\n            .map(column => column.index)\n    );\n    const childrenArray = React.Children.toArray(children);\n    return (\n        <Datagrid {...props}>\n            {columns === undefined\n                ? children\n                : columns.map(index => childrenArray[index])}\n        </Datagrid>\n    );\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}